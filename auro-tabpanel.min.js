import { x, a as i$2, i as i$3, T } from './lit-element.min.js';

// Copyright (c) Alaska Air. All right reserved. Licensed under the Apache-2.0 license
// See LICENSE in the project root for license information.

// ---------------------------------------------------------------------

/* eslint-disable line-comment-position, no-inline-comments, no-confusing-arrow, no-nested-ternary, implicit-arrow-linebreak */

class AuroLibraryRuntimeUtils {

  /* eslint-disable jsdoc/require-param */

  /**
   * This will register a new custom element with the browser.
   * @param {String} name - The name of the custom element.
   * @param {Object} componentClass - The class to register as a custom element.
   * @returns {void}
   */
  registerComponent(name, componentClass) {
    if (!customElements.get(name)) {
      customElements.define(name, class extends componentClass {});
    }
  }

  /**
   * Finds and returns the closest HTML Element based on a selector.
   * @returns {void}
   */
  closestElement(
    selector, // selector like in .closest()
    base = this, // extra functionality to skip a parent
    __Closest = (el, found = el && el.closest(selector)) =>
      !el || el === document || el === window
        ? null // standard .closest() returns null for non-found selectors also
        : found
          ? found // found a selector INside this element
          : __Closest(el.getRootNode().host) // recursion!! break out to parent DOM
  ) {
    return __Closest(base);
  }
  /* eslint-enable jsdoc/require-param */

  /**
   * If the element passed is registered with a different tag name than what is passed in, the tag name is added as an attribute to the element.
   * @param {Object} elem - The element to check.
   * @param {String} tagName - The name of the Auro component to check for or add as an attribute.
   * @returns {void}
   */
  handleComponentTagRename(elem, tagName) {
    const tag = tagName.toLowerCase();
    const elemTag = elem.tagName.toLowerCase();

    if (elemTag !== tag) {
      elem.setAttribute(tag, true);
    }
  }

  /**
   * Validates if an element is a specific Auro component.
   * @param {Object} elem - The element to validate.
   * @param {String} tagName - The name of the Auro component to check against.
   * @returns {Boolean} - Returns true if the element is the specified Auro component.
   */
  elementMatch(elem, tagName) {
    const tag = tagName.toLowerCase();
    const elemTag = elem.tagName.toLowerCase();

    return elemTag === tag || elem.hasAttribute(tag);
  }

  /**
   * Gets the text content of a named slot.
   * @returns {String}
   * @private
   */
  getSlotText(elem, name) {
    const slot = elem.shadowRoot?.querySelector(`slot[name="${name}"]`);
    const nodes = slot?.assignedNodes({ flatten: true }) || [];
    const text = nodes.map(n => n.textContent?.trim()).join(' ').trim();

    return text || null;
  }
}

/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const a=Symbol.for(""),o$1=t=>{if(t?.r===a)return t?._$litStatic$},l=new Map,n$1=t=>(r,...e)=>{const a=e.length;let s,i;const n=[],u=[];let c,$=0,f=false;for(;$<a;){for(c=r[$];$<a&&void 0!==(i=e[$],s=o$1(i));)c+=s+r[++$],f=true;$!==a&&u.push(i),n.push(c),$++;}if($===a&&n.push(r[a]),f){const t=n.join("$$lit$$");void 0===(r=l.get(t))&&(n.raw=n,l.set(t,r=n)),e=u;}return t(r,...e)},u=n$1(x);

var styleCss$2 = i$2`:host #tab-root{cursor:pointer;white-space:nowrap}:host([disabled]){pointer-events:none}:host(:focus-within),:host(:focus:not(:focus-visible)){position:relative;outline-color:unset;outline-style:none;outline-width:unset}:host(:focus-within):before,:host(:focus:not(:focus-visible)):before{position:absolute;top:0;left:50%;display:inline-block;width:100%;height:calc(100% + var(--ds-size-50, .25rem));border:1px solid var(--ds-color-border-active-default, #0074c8);border-radius:var(--ds-border-radius, .375rem);content:"";transform:translate(-50%)}:host([onDark]:focus-within):before,:host([onDark]:focus:not(:focus-visible)):before,:host([appearance=inverse]:focus-within):before,:host([appearance=inverse]:focus:not(:focus-visible)):before{border-color:var(--ds-advanced-color-state-focused-inverse, #ffffff)}:host(:not([onDark]):focus-within):before,:host(:not([onDark]):focus:not(:focus-visible)):before,:host(:not([appearance=inverse]):focus-within):before,:host(:not([appearance=inverse]):focus:not(:focus-visible)):before{border-color:var(--ds-advanced-color-state-focused, #01426a)}
`;

/* eslint-disable no-magic-numbers */
// Copyright (c) 2023 Alaska Airlines. All right reserved. Licensed under the Apache-2.0 license
// See LICENSE in the project root for license information.


/**
 * Represents a tab within an auro-tabgroup element. When selected, displays the corresponding AuroTabpanel.
 * The auro-tabpanel element should only be used inside an AuroTabgroup element.
 */
class AuroTab extends i$3 {
  static get properties() {
    return {
      /**
       * Defines whether the component will be on lighter or darker backgrounds.
       * @type {"default" | "inverse" | string} 
       * @prop {String} appearance
       * @default "default"
       */
      appearance: {
        type: String,
        reflect: true,
        default: "default"
      },

      /**
       * Indicates whether the tab is selected.
       * @prop {boolean} selected
       * @default false
       */
      selected: {
        type: Boolean,
        reflect: true,
      },

      /**
       * Indicates whether the tab is focused.
       * @property {boolean} focused 
       * @default false
       * @private
       */
      focused: {
        type: Boolean,
        state: true,
      },

      /**
       * Indicates whether the tab is disabled.
       * @property {boolean} disabled
       * @default false
       */
      disabled: {
        type: Boolean,
        reflect: true,
      },

      /**
       * The variant of the tab.
       * @type {"default" | "unstyled" | string}
       * @property {String} variant
       * @default "default"
       */
      variant: {
        type: String,
        reflect: true,
      },
    };
  }

  static get styles() {
    return [styleCss$2];
  }

  constructor() {
    super();

    AuroTab.incrementInstanceCount();

    this.handleTagName();
    this.setId();
    this.setInitialValues();
    this.setAttributes();
    this.addEventListeners();
  }

  /**
   * @static
   * @private
   * @description Increments the instance count of this component.
   * @method incrementInstanceCount
   * @returns {void}
   */
  static incrementInstanceCount() {
    AuroTab.instanceCount = (AuroTab.instanceCount || 0) + 1;
  }

  /**
   * Add event listeners for the component.
   * @returns {void}
   * @private
   */
  addEventListeners() {
    this.addEventListener("keydown", this.onKeyDown);
  }

  /**
   * Handles the keydown event for the tab.
   * @param {KeyboardEvent} event - The keydown event.
   * @private
   */
  onKeyDown = (event) => {
    if (event.key === "Enter" || event.key === " ") {
      this.selected = true;
      event.preventDefault();
    }
  };

  /**
   * Sets the focus state for the tab.
   * @param {boolean} focused - Whether the tab should be focused.
   * @private
   */
  setFocused(focused) {
    if (focused) this.focus();
    this.focused = focused;
    this.setAttribute("tabindex", focused ? 0 : -1);
    this.dispatchCustomEvent(focused ? "tab-focused" : "tab-blurred", this);
  }

  /**
   * @private
   * @description Sets the unique ID for this instance of the component.
   * @method setId
   * @returns {void}
   */
  setId() {
    this.id = this.id || `auro-tab-${AuroTab.instanceCount}`;
  }

  /**
   * @description Sets the initial values for the component.
   * @method setInitialValues
   * @private
   */
  setInitialValues() {
    // Dynamic properties
    this.disabled = false;
    this.appearance = "default";

    // Static properties
    /**
     * @property {AuroTabpanel} panel - The associated AuroTabpanel that will be displayed when this tab is selected.
     * @readonly
     */
    this.panel = null;
  }

  /**
   * @private
   * @description Sets the relevant attributes on the parent element for this component.
   * @method setAttributes
   */
  setAttributes() {
    this.setAttribute("role", "tab");
  }

  /**
   * @description Handles any custom tag naming of the component.
   * @method handleTagName
   * @private
   */
  handleTagName() {
    AuroLibraryRuntimeUtils.prototype.handleComponentTagRename(
      this,
      "auro-tab",
    );
  }

  /**
   * @description Applies changes to the component required for proper a11y functionality
   * @method applyA11y
   * @private
   */
  applyA11y() {
    // remove nested anchor tag's role to avoid nested interactive elements issue. WCAG 4.1.2
    const anchor = this.shadowRoot.querySelector("a");
    if (anchor) {
      anchor.setAttribute("role", "none");
    }
  }

  /**
   * @description Updates the selected state of the tab and emits the tab-selected event.
   * @method updateSelected
   * @returns {void}
   * @private
   */
  updateSelected() {
    // Update relevant attributes
    this.setAttribute("tabindex", this.selected || this.focused ? 0 : -1);
    this.setAttribute("aria-selected", this.selected ? "true" : "false");

    // Emit event if this tab is selected
    if (this.selected) {
      this.dispatchCustomEvent("tab-selected", this);
    }
  }

  /**
   * Dispatch a custom event from the component.
   * @param {string} eventName - The name of the event to dispatch.
   * @param {*} detail - The detail payload to include with the event.
   * @private
   */
  dispatchCustomEvent(eventName, detail) {
    const event = new CustomEvent(eventName, {
      bubbles: true,
      composed: true,
      detail,
    });
    this.dispatchEvent(event);
  }

  /**
   * This will register this element with the browser.
   * @param {string} [name="auro-tab"] - The name of element that you want to register to.
   *
   * @example
   * Aurotab.register("custom-tab") // this will register this element to <custom-tab/>
   *
   */
  static register(name = "auro-tab") {
    AuroLibraryRuntimeUtils.prototype.registerComponent(name, AuroTab);
  }

  firstUpdated() {
    this.applyA11y();
  }

  updated(changedProperties) {
    if (changedProperties.has("selected")) {
      this.updateSelected();
    }
  }

  render() {
    return u`
      <div part="tab-root" id="tab-root">
        <slot></slot>
      </div>
    `;
  }
}

/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t={ATTRIBUTE:1},e=t=>(...e)=>({_$litDirective$:t,values:e});let i$1 = class i{constructor(t){}get _$AU(){return this._$AM._$AU}_$AT(t,e,i){this._$Ct=t,this._$AM=e,this._$Ci=i;}_$AS(t,e){return this.update(t,e)}update(t,e){return this.render(...e)}};

/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const n="important",i=" !"+n,o=e(class extends i$1{constructor(t$1){if(super(t$1),t$1.type!==t.ATTRIBUTE||"style"!==t$1.name||t$1.strings?.length>2)throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.")}render(t){return Object.keys(t).reduce(((e,r)=>{const s=t[r];return null==s?e:e+`${r=r.includes("-")?r:r.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g,"-$&").toLowerCase()}:${s};`}),"")}update(e,[r]){const{style:s}=e.element;if(void 0===this.ft)return this.ft=new Set(Object.keys(r)),this.render(r);for(const t of this.ft)null==r[t]&&(this.ft.delete(t),t.includes("-")?s.removeProperty(t):s[t]=null);for(const t in r){const e=r[t];if(null!=e){this.ft.add(t);const r="string"==typeof e&&e.endsWith(i);t.includes("-")||r?s.setProperty(t,r?e.slice(0,-11):e,r?n:""):s[t]=e;}}return T}});

/**
 * @class ChildItemService
 * @description Service class that manages child items and exposes methods to add, remove, and subscribe to changes in the items array.
 * This service allows components to:
 * - Add and remove themselves/items from the service
 * - Subscribe to notifications when items change
 * - Track previous state of items for comparison
 * The service implements a simple pub/sub pattern to notify components when the items collection changes.
 */
class ChildItemService {
  /**
   * @property {Array} items - An array to hold the auro-scrolleritems in the scroller.
   * @private
   */
  #items = [];

  /**
   * @property {Array} previousItems - An array to hold the previous items in the scroller.
   * @private
   */
  #previousItems = [];

  /**
   * @property {Array} subscribers - An array to hold the subscribers for item changes.
   * @private
   */
  #subscribers = [];

  /**
   * @property {Object[]} current - A getter to access the current items in the scroller.
   */
  get current() {
    return this.#items;
  }

  /**
   * @param {Function} callback - A callback function that will be called when the items change.
   * @description This method allows you to subscribe to changes in the items array.
   * @returns {Function} - A function to unsubscribe from the changes.
   * @throws {Error} - Throws an error if the callback is not a function.
   */
  subscribe(callback) {
    if (typeof callback !== "function")
      throw new Error(
        "AuroTabService | subscribe: Callback must be a function",
      );
    this.#subscribers.push(callback);

    return () => this.unsubscribe(callback);
  }

  /**
   * @param {Function} callback - A callback function that will be called when the items change.
   * @description This method allows you to unsubscribe from changes in the items array.
   * @returns {Boolean} - Whether or not you were successfully unsubscribed.
   * @throws {Error} - Throws an error if the callback is not a function.
   */
  unsubscribe(callback) {
    if (typeof callback !== "function")
      throw new Error(
        "AuroTabService | unsubscribe: Callback must be a function",
      );
    this.#subscribers = this.#subscribers.filter(
      (subscriber) => subscriber !== callback,
    );

    return true;
  }

  /**
   * Notify all subscribers of changes in the items array.
   */
  #notifySubscribers() {
    for (const callback of this.#subscribers)
      callback(this.#items, this.#previousItems);
  }

  /**
   * @param {Object} item - An item to add to the scroller.
   * @description This method adds an item to the scroller and notifies subscribers.
   * @returns {void}
   * @throws {Error} - Throws an error if the item is not an object.
   */
  add(item) {
    if (typeof item !== "object" || item === null)
      throw new Error("AuroTabService | addItem: Item must be an object");

    this.#previousItems = this.#getPreviousItems();
    this.#items.push(item);
    this.#notifySubscribers();
  }

  /**
   * @description This method adds multiple items to the service and notifies subscribers.
   * @param {ArrayLike<any>} items
   * @returns {void}
   * @throws {Error} - Throws an error if the items are not iterable.
   */
  addMany(items) {
    if (
      !items ||
      typeof items[Symbol.iterator] !== "function" || // otherwise, check if it's iterable
      typeof items === "string" // technically string is iterable ;)
    ) {
      throw new Error(
        "AuroTabService | addMany: Items must be iterable (array, etc.)",
      );
    }

    this.#previousItems = this.#getPreviousItems();
    this.#items.push(...items);
    this.#notifySubscribers();
  }

  /**
   * @param {Object} item - An item to remove from the scroller.
   * @description This method removes an item from the scroller and notifies subscribers.
   * @returns {void}
   * @throws {Error} - Throws an error if the item is not an object or not found in the items array.
   */
  remove(item) {
    if (typeof item !== "object" || item === null)
      throw new Error("AuroTabService | removeItem: Item must be an object");

    this.#previousItems = this.#getPreviousItems();
    this.#items = this.#items.filter((i) => i !== item);
    this.#notifySubscribers();
  }

  clear() {
    this.#previousItems = this.#getPreviousItems();
    this.#items = [];
    this.#notifySubscribers();
  }

  /**
   * Gets an item by its index in the items array.
   * @param {Number} index
   * @returns {HTMLElement}
   */
  getItemByIndex(index) {
    return this.#items[index];
  }

  /**
   * Gets an item by its number (1-based index).
   * @param {Number} number
   * @returns {HTMLElement}
   */
  getItemByNumber(number) {
    if (
      this.#items.length === 0 ||
      typeof number !== "number" ||
      number < 0 ||
      number > this.#items.length
    ) {
      throw new Error(
        "AuroTabService | getItemByNumber: Number must be a valid index within the range of items.",
      );
    }
    return this.#items[number - 1];
  }

  getPreviousItem(currentNumber) {
    if (
      typeof currentNumber !== "number" ||
      currentNumber < 1 ||
      currentNumber > this.#items.length
    ) {
      throw new Error(
        "AuroTabService | getPreviousItem: Index must be a valid number within the range of previous items.",
      );
    }

    let index = currentNumber - 2; // Convert to 0-based index
    index = index < 0 ? this.#items.length - 1 : index;

    return this.#items[index];
  }

  getNextItem(currentNumber) {
    if (
      typeof currentNumber !== "number" ||
      currentNumber < 1 ||
      currentNumber > this.#items.length
    ) {
      throw new Error(
        "AuroTabService | getNextItem: Index must be a valid number within the range of previous items.",
      );
    }

    let index = currentNumber; // Convert to 0-based index
    index = index >= this.#items.length ? 0 : index;

    return this.#items[index];
  }

  #getPreviousItems() {
    return [...this.#items];
  }
}

var styleCss$1 = i$2`::slotted(auro-tabpanel){flex-basis:100%}:host{position:relative;display:block}.tabgroupContainer{display:flex;flex-direction:column;transition:scroll .5s ease-in-out}.tabgroup{position:relative;padding-bottom:0}.tabgroup ::slotted([slot=tabs]){display:flex;overflow:unset;width:fit-content;flex-wrap:nowrap}.sliderPositioner{position:absolute;bottom:-1px;left:0;display:flex;width:0;height:calc(var(--ds-size-25, .125rem) + 1px);align-items:center;justify-content:center;transition:all .25s}.slider{width:100%;height:100%}:host(:not([onDark])) .slider,:host(:not([appearance=inverse])) .slider{background-color:var(--ds-advanced-color-state-focused, #01426a)}:host([onDark]) .slider,:host([appearance=inverse]) .slider{background-color:var(--ds-advanced-color-state-focused-inverse, #ffffff)}
`;

class TabIndexUtil {
  // we check if previous tab have 'disabled' attribute and check the following previous tab for the same thing,
  // and keeps goind on until we found the one that's not disabled.
  static getPreviousNotDisabledIndex(focusedIdx, tabs) {
    let newIdx = focusedIdx;
    const decrement = () => {
      if (newIdx === 0) {
        newIdx = tabs.length - 1;
      } else {
        newIdx -= 1;
      }
    };
    // do increment for first time.
    decrement();

    while (tabs[newIdx].hasAttribute("disabled")) {
      decrement();
    }
    return newIdx;
  }

  // we check if next tab have 'disabled' attribute and check the following next tab for the same thing,
  // and keeps goind on until we found the one that's not disabled.
  static findNextNotDisabledIndex(focusedIdx, tabs) {
    let newIdx = focusedIdx;
    const increment = () => {
      if (newIdx === tabs.length - 1) {
        newIdx = 0;
      } else {
        newIdx += 1;
      }
    };
    // do increment for first time.
    increment();

    while (tabs[newIdx].hasAttribute("disabled")) {
      increment();
    }
    return newIdx;
  }
}

/* eslint-disable no-magic-numbers, max-lines, id-length, no-plusplus */
// Copyright (c) 2023 Alaska Airlines. All right reserved. Licensed under the Apache-2.0 license
// See LICENSE in the project root for license information.


// Import icon

const KEYCODE = {
  LEFT: "ArrowLeft",
  RIGHT: "ArrowRight",
  HOME: "Home",
  END: "End",
};

/**
 * The auro-tabgroup element is a container element for tabs and panels.
 * All children of `<auro-tabgroup>` should be either `<auro-tab>` or
 * `<auro-tabpanel>`. This element is stateless, meaning that no values are
 * cached and therefore, changes during runtime work.
 *
 * @slot tab - Slot component named for auro-tab.
 * @slot panel - Slot component named for auro-tabpanel.
 * @csspart tabgroup__root - The root element of the tab group.
 * @csspart tabgroup__tabs - The "tabs list" internal wrapper element.
 * @csspart tabgroup__panels - The panel wrapper element.
 * @csspart slider-positioner - The slider positioner element (non-visual, only used to center slider on tab).
 * @csspart slider - The slider element.
 * @attr {Boolean} ondark - DEPRECATED - use `appearance` instead.
 */
class AuroTabgroup extends i$3 {
  static get properties() {
    return {
      /**
       * Defines whether the component will be on lighter or darker backgrounds.
       * @type {"default" | "inverse" | string}
       * @property {String} appearance
       * @default 'default'
       */
      appearance: {
        type: String,
        reflect: true,
      },

      /**
       * @property {number} scrollPosition - The current scroll position of the tab group container.
       * @default 0
       * @private
       */
      scrollPosition: {
        type: Number,
      },

      /**
       * @property {Boolean} selectOnFocus - Whether or not to select the tab on focus.
       * @default false
       */
      selectOnFocus: {
        type: Boolean,
        reflect: true,
      },

      /**
       * @property {Object} sliderStyles - The styles for the slider element.
       * @default {}
       * @private
       */
      sliderStyles: {
        type: Object,
      },

      /**
       * @property {Boolean} rightChevronIsVisible - Whether or not the right chevron is visible.
       * @default false
       * @private
       */
      rightChevronIsVisible: {
        type: Boolean,
        attribute: false,
        reflect: false,
        default: true,
      },

      /**
       * @property {Boolean} leftChevronIsVisible - Whether or not the left chevron is visible.
       * @default false
       * @private
       */
      leftChevronIsVisible: {
        type: Boolean,
        attribute: false,
        reflect: false,
      },

      /**
       * @property {boolean} ondark - DEPRECATED - use `appearance` instead.
       * @default false
       */
      ondark: {
        type: Boolean,
        reflect: true,
      },
    };
  }

  /**
   * @description All auro-tab elements in the tab group.
   * @returns {Array<AuroTab>}
   * @private
   * @readonly
   */
  get allTabs() {
    return this.tabs.current;
  }

  /**
   * @description All auro-tab elements in the tab group.
   * @returns {Array<AuroTabpanel>}
   * @private
   * @readonly
   */
  get allPanels() {
    return this.panels.current;
  }

  /**
   * @description The index of the currently selected tab.
   * @returns {number}
   * @private
   * @readonly
   */
  get currentTabIndex() {
    return this.focusedTabIdx;
  }

  /**
   * @description Reference to the currently selected tab.
   * @returns {HTMLElement}
   * @private
   * @readonly
   */
  get currentTab() {
    return this.allTabs[this.focusedTabIdx];
  }

  /**
   * @description Getter for tab group container scroll size.
   * @returns {Number}
   * @private
   * @readonly
   */
  get scrollSize() {
    if (this.tabGroupContainer) {
      return (
        this.tabGroupContainer.scrollWidth - this.tabGroupContainer.clientWidth
      );
    }
    return 0;
  }

  /**
   * @description Whether or not the DOM is currently loading/updating elements.
   * @returns {Boolean}
   */
  get busy() {
    return this.getAttribute("aria-busy") === "true";
  }

  set busy(isBusy) {
    this.setAttribute("aria-busy", String(isBusy));
  }

  static get styles() {
    return [styleCss$1];
  }

  constructor() {
    super();

    this.handleTagName();
    this.setInitialValues();
    this.bindMethods();

    this.tabs = new ChildItemService();
    this.panels = new ChildItemService();

    this.tabs.subscribe(this.#handleTabPanelConnections);
    this.panels.subscribe(this.#handleTabPanelConnections);
  }

  /**
   * @description Handles any custom tag naming of the component.
   * @method handleTagName
   * @private
   */
  handleTagName() {
    AuroLibraryRuntimeUtils.prototype.handleComponentTagRename(
      this,
      "auro-tabgroup",
    );
  }

  /**
   * @description Sets the initial values for the component.
   * @method setInitialValues
   * @private
   */
  setInitialValues() {
    // Dynamic Properties
    this.scrollPosition = 0;
    this.sliderStyles = {};
    this.selectOnFocus = false;
    this.appearance = "default";

    // Static Properties
    /**
     * @property {number} focusedTabIdx - The index of the currently focused tab.
     * @default -1
     * @private
     */
    this.focusedTabIdx = -1;

    /**
     * @property {ResizeObserver} resizeObserver - The resize observer for the tab group.
     * @default undefined
     * @private
     */
    this.resizeObserver = undefined;
  }

  /**
   * @description Binds methods to the class instance where required (do NOT bind all methods).
   * @method bindMethods
   * @private
   */
  bindMethods() {
    this.handleTabSelected = this.handleTabSelected.bind(this);
    this.handleTabFocused = this.handleTabFocused.bind(this);
  }

  /**
   * This will register this element with the browser.
   * @param {string} [name="auro-tabgroup"] - The name of element that you want to register to.
   *
   * @example
   * Aurotab.register("custom-tabgroup") // this will register this element to <custom-tab/>
   *
   */
  static register(name = "auro-tabgroup") {
    AuroLibraryRuntimeUtils.prototype.registerComponent(name, AuroTabgroup);
  }

  /**
   * @description Propagates the ondark attribute to child tabs.
   * @method propagateOnDarkToTabs
   * @private
   */
  propagateOnDarkToTabs() {
    this.allTabs.forEach((tab) => {
      if (this.ondark) {
        tab.setAttribute("ondark", "");
      } else {
        tab.removeAttribute("ondark");
      }

      tab.setAttribute("appearance", this.appearance);
    });
  }

  /**
   * Loop through tabs and match with same-index panels.
   * @private
   * @returns {void}
   */
  #associateTabsWithPanels() {
    this.allTabs.forEach((currentTab, i) => {
      const matchingPanel = this.panels.getItemByIndex(i);

      if (!matchingPanel) {
        return;
      }

      // Hide panel
      matchingPanel.hidden = true;

      // Associate tab with the panel, and vice versa
      currentTab.panel = matchingPanel;
      currentTab.setAttribute("aria-controls", matchingPanel.id);
      matchingPanel.setAttribute("aria-labelledby", currentTab.id);

      if (currentTab.selected) {
        this.selectTab(currentTab);
      }
    });
  }

  /**
   * @description Function to add event listeners to the component.
   * @method addEventListeners
   * @private
   */
  addEventListeners() {
    this.addEventListener("tab-selected", this.handleTabSelected);
    this.addEventListener("tab-focused", this.handleTabFocused);
    this.addEventListener("keydown", this.onKeyDown);
    this.addEventListener("click", this.onClick);
  }

  /**
   * @description Function to remove event listeners from the component.
   * @method removeEventListeners
   * @private
   */
  removeEventListeners() {
    this.removeEventListener("keydown", this.onKeyDown);
    this.removeEventListener("click", this.onClick);
    this.resizeObserver?.disconnect();
  }

  /**
   * @description Handler for when an element is added or removed from
   * one of the shadow DOM slots.
   * @private
   */
  #handleTabPanelConnections = () => {
    // Update busy state to reflect changes are happening in the DOM
    this.busy = true;

    this.#associateTabsWithPanels();
    this.propagateOnDarkToTabs();

    // If none of the tabs were set to be focused, focus the first tab
    if (this.focusedTabIdx === -1 && this.allTabs[0]?.panel) {
      this.selectTab(this.allTabs[0]);
    }

    // We are no longer busy making changes
    this.busy = false;
  };

  /**
   * @description Select an auro tab by reference
   * @param {HTMLElement} newTab Selected auro-tab.
   */
  selectTab(newTab) {
    const tabs = this.allTabs;
    this.focusedTabIdx = -1;

    // Deselect all tabs and hide all panels.
    for (let i = 0; i < tabs.length; i++) {
      const tab = tabs[i];
      if (tab === newTab) {
        this.focusedTabIdx = i;
      }
      tab.selected = tab === newTab;

      if (tab.panel) {
        tab.panel.hidden = tab !== newTab;
      }
    }

    // This will scroll the container to selected tab to nearly centered
    // of the relative viewport if possible.
    if (this.scrollSize > 0) {
      const tabBounding = newTab.getBoundingClientRect();
      const halfWidth = this.tabGroupContainer.clientWidth / 2;
      this.tabGroupContainer.scrollBy({
        left: tabBounding.x - halfWidth,
        behavior: "smooth",
      });
    }

    // If that panel doesn’t exist, abort.
    if (!newTab.panel) {
      // eslint-disable-next-line no-console
      console.warn(`No panel with id ${newTab.id}`);
    }
  }

  /**
   * @description Select a tab by its index.
   * @param {number} index - The index of the tab to select.
   */
  selectTabByIndex(index) {
    const tab = this.tabs.current[index];
    if (tab) {
      this.selectTab(tab);
    }
  }

  /**
   * @description Function handler for keyDown event.
   * @private
   * @param {KeyboardEvent} event HTML onkeydown keyboard event.
   */
  onKeyDown(event) {
    // Don’t handle modifier shortcuts typically used by assistive technology.
    if (event.altKey) {
      return;
    }

    // Ignore events from non-tab elements and/or non tablist elements
    const role = event.target.getAttribute("role");
    if (role !== "tab" && role !== "tablist") {
      return;
    }

    // The switch-case will determine which tab should be marked as focused
    // depending on the key that was pressed.
    const tabs = this.allTabs;
    let newIdx = 0;
    // keyboard support
    // https://www.w3.org/WAI/ARIA/apg/patterns/tabs/examples/tabs-automatic/
    switch (event.key) {
      case KEYCODE.LEFT:
        newIdx = TabIndexUtil.getPreviousNotDisabledIndex(
          this.focusedTabIdx,
          tabs,
        );
        break;
      case KEYCODE.RIGHT:
        newIdx = TabIndexUtil.findNextNotDisabledIndex(
          this.focusedTabIdx,
          tabs,
        );
        break;
      case KEYCODE.HOME:
        newIdx = 0;
        break;
      case KEYCODE.END:
        newIdx = tabs.length - 1;
        break;
      default:
        // Any other key press is ignored and passed back to the browser.
        return;
    }

    this.focusedTabIdx = newIdx;

    // The browser might have some native functionality bound to the arrow
    // keys, home or end. The element calls `preventDefault()` to prevent the
    // browser from taking any actions.
    event.preventDefault();

    // Focus to the new tab, that has been determined in the switch-case.
    const newTab = tabs[newIdx];

    if (newTab) {
      // Set focus states for tabs
      this.tabs.current.forEach((tab, _index) => {
        tab.setFocused(tab === newTab);
      });

      if (this.selectOnFocus) {
        this.selectTab(newTab);
      }
    }
  }

  /**
   * @description Function handler for click event.
   * @method onClick
   * @param {Event} event HTML click Event.
   * @private
   */
  onClick(event) {
    const roleIsNotTab = event.target.getAttribute("role") !== "tab";
    const closestTab = event.target.closest("[role=tab]");

    // If the click was not targeted on a tab element itself,
    // it was a click inside the a panel or on empty space. Nothing to do.
    // actually this is going to be a known issue for custom auro-tab component name in the future
    if (roleIsNotTab && !closestTab && event.target.localName !== "auro-tab") {
      return;
    }

    if (closestTab) {
      this.selectTab(closestTab);
    } else {
      this.selectTab(event.target);
    }
  }

  /**
   * @description Sets the slider styles for the active tab.
   * @param {Event<tab-selected>} event Dispatched from auro-tab.
   * @private
   */
  handleTabSelected(event) {
    // Set the slider width to zero by default
    this.sliderStyles.width = 0;

    // Get the tab that was focused
    const tab = event.target;

    // Guard Clause: ensure we have a tab to work with
    if (!tab) {
      return;
    }

    // Update the selected tab if it was set externally
    this.selectTab(tab);

    // Update the slider styles based on the tab that was focused
    this.sliderStyles = {
      width: `${tab.clientWidth}px`,
      left: `${tab.offsetLeft - 0.5}px`,
    };
  }

  /**
   * Handles the tab focus event.
   * @param {FocusEvent} event - The focus event.
   * @private
   */
  handleTabFocused(event) {
    const tab = event.target;
    this.focusedTabIdx = this.tabs.current.indexOf(tab) || 0;
  }

  /**
   * @description Function to generate icon based in icon param.
   * @param {string} icon SVG string.
   * @returns {HTMLElement}
   * @private
   */
  generateIcon(icon) {
    const dom = new DOMParser().parseFromString(icon.svg, "text/html");
    return dom.body.firstChild;
  }

  /**
   * @description Function to save the tab group container scroll position state.
   * @method onTabGroupScroll
   * @private
   */
  onTabGroupScroll() {
    this.scrollPosition = this.tabGroupContainer.scrollLeft;
  }

  /**
   * @description Function handler for the scroll button click action.
   * @method scrollTab
   * @param {string} direction Direction of the scroll.
   * @private
   */
  scrollTab(direction) {
    if (this.tabGroupContainer) {
      switch (direction) {
        case "prev":
          if (this.tabGroupContainer.scrollLeft > 0) {
            this.tabGroupContainer.scrollBy({
              left: -this.tabGroupContainer.clientWidth,
              behavior: "smooth",
            });
          }
          break;
        case "next":
          if (this.tabGroupContainer.scrollLeft < this.scrollSize) {
            this.tabGroupContainer.scrollBy({
              left: this.tabGroupContainer.clientWidth,
              behavior: "smooth",
            });
          }
          break;
      }
    }
  }

  /**
   * @description Function to set the resize observer for the tab group and set it to observe the tabGroup.
   * @method setResizeObserver
   * @param {HTMLElement} tabGroupContainer The tab group container element.
   * @private
   */
  setResizeObserver(tabGroupContainer) {
    this.resizeObserver = new ResizeObserver(() => {
      this.handleTabSelected({ target: this.currentTab });
    });

    const tabGroup = tabGroupContainer.querySelector(".tabgroup");
    this.resizeObserver.observe(tabGroup, { box: "border-box" });
  }

  /**
   * @description Function to setup the tab group container.
   * @method setupTabGroupContainer
   * @private
   */
  setupTabGroupContainer() {
    this.tabGroupContainer =
      this.shadowRoot.querySelector(".tabgroupContainer");
    this.tabGroupContainer.addEventListener("scroll", () =>
      this.onTabGroupScroll(),
    );
  }

  /**
   * @description Update the chevron visibility when the state of the component changes.
   * @method updateChevronVisibility
   * @private
   */
  updateChevronVisibility() {
    this.leftChevronIsVisible =
      (this.scrollPosition >= this.scrollSize || this.scrollPosition !== 0) &&
      this.scrollSize > 0;
    this.rightChevronIsVisible =
      (this.scrollPosition === 0 || this.scrollPosition < this.scrollSize) &&
      this.scrollSize > 0;
  }

  firstUpdated() {
    this.setupTabGroupContainer();
    this.setResizeObserver(this.tabGroupContainer);
  }

  updated(changedProperties) {
    this.updateChevronVisibility();

    if (
      changedProperties.has("appearance") ||
      changedProperties.has("ondark")
    ) {
      this.propagateOnDarkToTabs();
    }
  }

  connectedCallback() {
    super.connectedCallback();
    this.addEventListeners();
  }

  disconnectedCallback() {
    this.removeEventListeners();
  }

  /**
   * @private
   */
  #onSlotChange = () => {
    const tabs = this.querySelectorAll("auro-tab, [auro-tab]");
    const panels = this.querySelectorAll("auro-tabpanel, [auro-tabpanel]");

    // Clear previous state
    this.tabs.clear();
    this.panels.clear();

    // Populate new state
    this.tabs.addMany(tabs);
    this.panels.addMany(panels);

    // Connect tabs with panels using child service registrations
    this.#handleTabPanelConnections();
  };

  // function that renders the HTML and CSS into the scope of the component
  render() {
    const sliderStyles = o(this.sliderStyles);

    return x`
      <div part="tabgroup__root" class="tabgroupContainer">
        <div part="tabgroup__tabs" class="tabgroup" role="tablist">
          <slot name="tabs" @slotchange="${this.#onSlotChange}"></slot>
          <div part="slider-positioner" class="sliderPositioner" style=${sliderStyles}>
            <div part="slider" class="slider"></div>
          </div>
        </div>

        <div part="tabgroup__panels">
            <slot name="panels" @slotchange="${this.#onSlotChange}"></slot>
        </div>
      </div>
    `;
  }
}

var styleCss = i$2`:host{display:block;width:100%}:host([hidden]){display:none}
`;

// Copyright (c) 2023 Alaska Airlines. All right reserved. Licensed under the Apache-2.0 license
// See LICENSE in the project root for license information.


/**
 * Represents a panel to be displayed when the corresponding tab is selected in an AuroTabgroup element.
 * The auro-tabpanel element should only be used inside an AuroTabgroup element.
 */
class AuroTabpanel extends i$3 {
  static get properties() {
    return {
      /**
       * Indicates whether the panel is hidden.
       * @property {boolean} hidden
       * @default false
       */
      hidden: {
        type: Boolean,
        reflect: true,
      },
    };
  }

  static get styles() {
    return [styleCss];
  }

  constructor() {
    super();

    AuroTabpanel.incrementInstanceCount();

    this.handleTagName();
    this.setId();
    this.setAttributes();
  }

  /**
   * @static
   * @private
   * @description Increments the instance count of this component.
   * @method incrementInstanceCount
   * @returns {void}
   */
  static incrementInstanceCount() {
    AuroTabpanel.instanceCount = (AuroTabpanel.instanceCount || 0) + 1;
  }

  /**
   * This will register this element with the browser.
   * @param {string} [name="auro-tabpanel"] - The name of element that you want to register to.
   *
   * @example
   * Aurotab.register("custom-tabpanel") // this will register this element to <custom-tab/>
   *
   */
  static register(name = "auro-tabpanel") {
    AuroLibraryRuntimeUtils.prototype.registerComponent(name, AuroTabpanel);
  }

  /**
   * @description Handles any custom tag naming of the component.
   * @method handleTagName
   * @returns {void}
   * @private
   */
  handleTagName() {
    AuroLibraryRuntimeUtils.prototype.handleComponentTagRename(
      this,
      "auro-tabpanel",
    );
  }

  /**
   * @private
   * @description Sets the unique ID for this instance of the component.
   * @method setId
   * @returns {void}
   */
  setId() {
    this.id = this.id || `auro-tabpanel-${AuroTabpanel.instanceCount}`;
  }

  /**
   * @private
   * @description Sets the relevant attributes on the parent element for this component.
   * @method setAttributes
   * @returns {void}
   */
  setAttributes() {
    this.setAttribute("role", "tabpanel");
    this.setAttribute("tabindex", 0);
  }

  updated(changedProperties) {
    if (changedProperties.has("hidden")) {
      this.setAttribute("tabindex", this.hidden ? -1 : 0); // eslint-disable-line no-magic-numbers
    }
  }

  render() {
    return x`
      <slot></slot>
    `;
  }
}

export { AuroTabpanel as A, AuroTab as a, AuroTabgroup as b };
